/*
 * Copyright 2014-2016 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.atlas.wiki

import java.io.File
import java.io.InputStream
import java.io.OutputStream

import akka.actor.ActorSystem
import akka.actor.Props
import com.netflix.atlas.akka.RequestHandlerActor
import com.netflix.atlas.core.model.DataVocabulary
import com.netflix.atlas.core.model.FilterVocabulary
import com.netflix.atlas.core.model.MathVocabulary
import com.netflix.atlas.core.model.QueryVocabulary
import com.netflix.atlas.core.model.StatefulVocabulary
import com.netflix.atlas.core.model.StyleVocabulary
import com.netflix.atlas.core.stacklang.StandardVocabulary
import com.netflix.atlas.core.util.Streams._
import com.netflix.atlas.webapi.ApiSettings
import com.netflix.atlas.webapi.LocalDatabaseActor
import com.netflix.atlas.wiki.pages.DES
import com.netflix.atlas.wiki.pages.DesEpicSignal
import com.netflix.atlas.wiki.pages.DesEpicViz
import com.netflix.atlas.wiki.pages.DistStddev
import com.netflix.atlas.wiki.pages.StackLanguageReference
import com.netflix.atlas.wiki.pages.TimeZones
import com.typesafe.scalalogging.StrictLogging

import scala.concurrent.Await
import scala.concurrent.duration.Duration


/**
 * Simple script for processing the wiki docs. Custom pages can be generated by creating a simple
 * class. Markdown pages can include a line that starts with `/api/v1/graph` to include a
 * rendered image using the graph api and a formatted expression.
 */
object Main extends StrictLogging {

  type ListBuilder = scala.collection.mutable.Builder[String, List[String]]

  val system = ActorSystem("wiki")
  val db = ApiSettings.newDbInstance
  system.actorOf(Props(new LocalDatabaseActor(db)), "db")
  val webApi = system.actorOf(Props[RequestHandlerActor])

  private def writeFile(data: String, f: File): Unit = {
    scope(fileOut(f)) { _.write(data.getBytes("UTF-8")) }
  }

  @scala.annotation.tailrec
  private def process(lines: List[String], output: ListBuilder, graph: GraphHelper): List[String] = {
    lines match {
      case v :: vs if v.trim.startsWith("/api/v1/graph") =>
        output += graph.image(v)
        process(vs, output, graph)
      case v :: vs =>
        output += v
        process(vs, output, graph)
      case Nil =>
        output.result()
    }
  }

  private def processTemplate(f: File, output: File): Unit = {
    val path = s"${output.getName}/gen-images"
    val graph = new GraphHelper(webApi, new File(output, "gen-images"), path)
    val template = scope(fileIn(f)) { in => lines(in).toList }
    val processed = process(template, List.newBuilder[String], graph)
    writeFile(processed.mkString("\n"), new File(output, f.getName))
  }

  private def copyVerbatim(f: File, output: File): Unit = {
    logger.info(s"copy verbatim: $f to $output")
    copyVerbatim(fileIn(f), fileOut(new File(output, f.getName)))
  }

  private def copyVerbatim(fin: InputStream, fout: OutputStream): Unit = {
    scope(fout) { out =>
      scope(fin) { in =>
        val buf = new Array[Byte](4096)
        var length = in.read(buf)
        while (length > 0) {
          out.write(buf, 0, length)
          length = in.read(buf)
        }
      }
    }
  }

  private def copy(input: File, output: File): Unit = {
    if (!output.exists) {
      logger.info(s"creating directory: $output")
      output.mkdir()
    }
    require(output.isDirectory, s"could not find or create directory: $output")
    input.listFiles.foreach {
      case f if f.isDirectory             => copy(f, new File(output, f.getName))
      case f if f.getName.endsWith(".md") => processTemplate(f, output)
      case f                              => copyVerbatim(f, output)
    }
  }

  private def generateStackLangRef(output: File): Unit = {
    val dir = new File(output, "stacklang")
    dir.mkdirs()

    val graph = new GraphHelper(webApi, new File(dir, "gen-images"), "stacklang/gen-images")

    val vocabs = List(
      StandardVocabulary,
      QueryVocabulary,
      DataVocabulary,
      MathVocabulary,
      StatefulVocabulary,
      FilterVocabulary,
      StyleVocabulary
    )

    val overrides = Map(
      DesEpicSignal.word -> DesEpicSignal,
      DesEpicViz.word    -> DesEpicViz,
      DistStddev.word    -> DistStddev
    )

    val sidebar = new StringBuilder
    sidebar.append("###[Home](Home) > Stack Language Reference\n")

    vocabs.foreach { vocab =>
      sidebar.append(s"\n**${vocab.name}**\n")
      vocab.words.sortWith(_.name < _.name).foreach { w =>
        val page = overrides.getOrElse(w, BasicStackWordPage(vocab, w))
        val fname = page.name
        sidebar.append(s"* [${w.name}]($fname)\n")
        val f = new File(dir, s"$fname.md")
        writeFile(page.content(graph), f)
      }
    }

    writeFile(sidebar.toString(), new File(dir, "_Sidebar.md"))
  }

  def generateScriptedPages(output: File, pages: List[Page]): Unit = {
    val graph = new GraphHelper(webApi, new File(output, "gen-images"), "gen-images")
    pages.foreach { p => writeFile(p.content(graph), p.file(output)) }
  }

  def main(args: Array[String]): Unit = {
    try {
      if (args.length != 2) {
        System.err.println("Usage: Main <input-dir> <output-dir>")
        System.exit(1)
      }

      val input = new File(args(0))
      require(input.isDirectory, s"input-dir is not a directory: $input")

      val output = new File(args(1))
      output.mkdirs()
      require(output.isDirectory, s"could not find or create output directry: $output")

      copy(input, output)

      generateStackLangRef(output)
      generateScriptedPages(output, List(
        new DES,
        new StackLanguageReference,
        new TimeZones
      ))
    } finally {
      Await.ready(system.terminate(), Duration.Inf)
    }
  }
}
